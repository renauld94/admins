<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infrastructure Monitoring | Simon Renauld - Data Engineering</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4F46E5;
            --secondary-color: #7C3AED;
            --accent-color: #06B6D4;
            --bg-dark: #0F172A;
            --bg-card: #1E293B;
            --bg-hover: #334155;
            --text-primary: #F8FAFC;
            --text-secondary: #CBD5E1;
            --text-muted: #64748B;
            --border-color: #334155;
            --success: #10B981;
            --warning: #F59E0B;
            --error: #EF4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        .header {
            max-width: 1400px;
            margin: 0 auto 40px;
            padding: 30px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .header-title {
            flex: 1;
            min-width: 300px;
        }

        h1 {
            font-size: 32px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 8px;
            letter-spacing: -0.025em;
        }

        .subtitle {
            font-size: 16px;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(16, 185, 129, 0.1);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            color: var(--success);
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .metrics-grid {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-bottom: 40px;
        }

        .metric-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 24px;
            transition: all 0.2s ease;
        }

        .metric-card:hover {
            background: var(--bg-hover);
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .metric-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .metric-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: rgba(79, 70, 229, 0.1);
            border: 1px solid rgba(79, 70, 229, 0.2);
        }

        .metric-value-container {
            margin-bottom: 16px;
        }

        .metric-value {
            font-size: 48px;
            font-weight: 700;
            color: var(--text-primary);
            line-height: 1;
            letter-spacing: -0.02em;
        }

        .metric-unit {
            font-size: 18px;
            color: var(--text-muted);
            font-weight: 400;
            margin-left: 4px;
        }

        .metric-chart {
            height: 80px;
            width: 100%;
            margin-top: 16px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 12px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            border-radius: 3px;
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .sparkline {
            fill: none;
            stroke: var(--primary-color);
            stroke-width: 2;
            filter: drop-shadow(0 0 4px rgba(79, 70, 229, 0.5));
        }

        .sparkline-area {
            fill: url(#gradient);
            opacity: 0.2;
        }

        .tech-stack {
            max-width: 1400px;
            margin: 40px auto 0;
            padding: 32px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .tech-stack-title {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 20px;
            letter-spacing: -0.01em;
        }

        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tech-tag {
            padding: 8px 14px;
            background: rgba(79, 70, 229, 0.1);
            border: 1px solid rgba(79, 70, 229, 0.2);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .tech-tag:hover {
            background: rgba(79, 70, 229, 0.2);
            border-color: var(--primary-color);
            color: var(--text-primary);
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
            font-size: 16px;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% {
                content: '.';
            }
            40% {
                content: '..';
            }
            60%, 100% {
                content: '...';
            }
        }

        .footer {
            max-width: 1400px;
            margin: 60px auto 0;
            padding: 32px 0;
            border-top: 1px solid var(--border-color);
            text-align: center;
        }

        .footer-content {
            font-size: 14px;
            color: var(--text-muted);
        }

        .footer-link {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .footer-link:hover {
            color: var(--accent-color);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 24px;
            }
            
            .metric-value {
                font-size: 36px;
            }
            
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="header-title">
                <h1>Infrastructure Monitoring</h1>
                <p class="subtitle">Real-time metrics from Proxmox AI infrastructure</p>
            </div>
            <div class="status-badge">
                <span class="status-indicator"></span>
                <span>Live Data</span>
            </div>
        </div>
    </div>

    <div id="dashboard" class="metrics-grid">
        <div class="loading">Loading metrics from Prometheus</div>
    </div>

    <div class="tech-stack">
        <h3 class="tech-stack-title">Technology Stack</h3>
        <div class="tech-tags">
            <span class="tech-tag">Prometheus</span>
            <span class="tech-tag">Grafana</span>
            <span class="tech-tag">Node Exporter</span>
            <span class="tech-tag">Docker</span>
            <span class="tech-tag">Proxmox VE</span>
            <span class="tech-tag">ZFS Storage</span>
            <span class="tech-tag">PostgreSQL</span>
            <span class="tech-tag">D3.js</span>
        </div>
    </div>

    <div class="footer">
        <div class="footer-content">
            <p>Built by <a href="http://simondatalab.de/" class="footer-link" target="_blank">Simon Renauld</a></p>
            <p style="margin-top: 8px; font-size: 12px;">Production-grade monitoring for AI infrastructure</p>
        </div>
    </div>

    <script>
        const PROMETHEUS_URL = 'https://prometheus.simondatalab.de';
        const REFRESH_INTERVAL = 15000;

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
        }

        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            return `${days}d ${hours}h`;
        }

        async function fetchPrometheusQuery(query) {
            try {
                const url = `${PROMETHEUS_URL}/api/v1/query?query=${encodeURIComponent(query)}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.status === 'success' && data.data.result.length > 0) {
                    return parseFloat(data.data.result[0].value[1]);
                }
                return null;
            } catch (error) {
                console.error('Prometheus query error:', error);
                return null;
            }
        }

        async function fetchPrometheusRange(query, duration = '1h') {
            try {
                const end = Math.floor(Date.now() / 1000);
                const start = end - (duration === '1h' ? 3600 : 86400);
                const url = `${PROMETHEUS_URL}/api/v1/query_range?query=${encodeURIComponent(query)}&start=${start}&end=${end}&step=60`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.status === 'success' && data.data.result.length > 0) {
                    return data.data.result[0].values.map(v => ({
                        time: v[0] * 1000,
                        value: parseFloat(v[1])
                    }));
                }
                return [];
            } catch (error) {
                console.error('Prometheus range query error:', error);
                return [];
            }
        }

        function createMetricCard(config) {
            const card = document.createElement('div');
            card.className = 'metric-card';
            card.innerHTML = `
                <div class="metric-header">
                    <span class="metric-label">${config.label}</span>
                    <div class="metric-icon">${config.icon}</div>
                </div>
                <div class="metric-value-container">
                    <span class="metric-value" id="${config.id}-value">--</span>
                    <span class="metric-unit">${config.unit}</span>
                </div>
                ${config.showProgress ? '<div class="progress-bar"><div class="progress-fill" id="' + config.id + '-progress"></div></div>' : ''}
                <svg class="metric-chart" id="${config.id}-chart"></svg>
            `;
            return card;
        }

        function drawSparkline(elementId, data, color = '#4F46E5') {
            const svg = d3.select(`#${elementId}`);
            svg.selectAll('*').remove();

            if (!data || data.length === 0) return;

            const width = svg.node().getBoundingClientRect().width;
            const height = 80;
            const margin = { top: 10, right: 10, bottom: 10, left: 10 };

            const x = d3.scaleTime()
                .domain(d3.extent(data, d => new Date(d.time)))
                .range([margin.left, width - margin.right]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.value) * 1.1])
                .range([height - margin.bottom, margin.top]);

            const gradient = svg.append('defs')
                .append('linearGradient')
                .attr('id', `gradient-${elementId}`)
                .attr('x1', '0%')
                .attr('y1', '0%')
                .attr('x2', '0%')
                .attr('y2', '100%');

            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', color)
                .attr('stop-opacity', 0.3);

            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', color)
                .attr('stop-opacity', 0);

            const area = d3.area()
                .x(d => x(new Date(d.time)))
                .y0(height - margin.bottom)
                .y1(d => y(d.value))
                .curve(d3.curveMonotoneX);

            svg.append('path')
                .datum(data)
                .attr('class', 'sparkline-area')
                .attr('d', area)
                .attr('fill', `url(#gradient-${elementId})`);

            const line = d3.line()
                .x(d => x(new Date(d.time)))
                .y(d => y(d.value))
                .curve(d3.curveMonotoneX);

            const path = svg.append('path')
                .datum(data)
                .attr('class', 'sparkline')
                .attr('d', line)
                .attr('stroke', color);

            const pathLength = path.node().getTotalLength();
            path
                .attr('stroke-dasharray', pathLength)
                .attr('stroke-dashoffset', pathLength)
                .transition()
                .duration(1500)
                .ease(d3.easeCubicOut)
                .attr('stroke-dashoffset', 0);
        }

        async function updateDashboard() {
            const cpuUsage = await fetchPrometheusQuery(
                '100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle",job="proxmox-host"}[5m])) * 100)'
            );
            if (cpuUsage !== null) {
                document.getElementById('cpu-value').textContent = cpuUsage.toFixed(1);
                const progress = document.getElementById('cpu-progress');
                if (progress) progress.style.width = cpuUsage + '%';
            }

            const cpuHistory = await fetchPrometheusRange(
                '100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle",job="proxmox-host"}[5m])) * 100)'
            );
            if (cpuHistory.length > 0) {
                drawSparkline('cpu-chart', cpuHistory, '#F59E0B');
            }

            const memTotal = await fetchPrometheusQuery('node_memory_MemTotal_bytes{job="proxmox-host"}');
            const memAvail = await fetchPrometheusQuery('node_memory_MemAvailable_bytes{job="proxmox-host"}');
            if (memTotal && memAvail) {
                const memUsage = ((memTotal - memAvail) / memTotal) * 100;
                document.getElementById('memory-value').textContent = memUsage.toFixed(1);
                const progress = document.getElementById('memory-progress');
                if (progress) progress.style.width = memUsage + '%';
            }

            const memHistory = await fetchPrometheusRange(
                '100 * (1 - (node_memory_MemAvailable_bytes{job="proxmox-host"} / node_memory_MemTotal_bytes{job="proxmox-host"}))'
            );
            if (memHistory.length > 0) {
                drawSparkline('memory-chart', memHistory, '#10B981');
            }

            const diskTotal = await fetchPrometheusQuery('node_filesystem_size_bytes{job="proxmox-host",mountpoint="/"}');
            const diskFree = await fetchPrometheusQuery('node_filesystem_free_bytes{job="proxmox-host",mountpoint="/"}');
            if (diskTotal && diskFree) {
                const diskUsage = ((diskTotal - diskFree) / diskTotal) * 100;
                document.getElementById('disk-value').textContent = diskUsage.toFixed(1);
                const progress = document.getElementById('disk-progress');
                if (progress) progress.style.width = diskUsage + '%';
            }

            const netRx = await fetchPrometheusQuery('irate(node_network_receive_bytes_total{job="proxmox-host",device!="lo"}[5m]) / 1024 / 1024');
            if (netRx !== null) {
                document.getElementById('network-value').textContent = netRx.toFixed(2);
            }

            const netHistory = await fetchPrometheusRange(
                'irate(node_network_receive_bytes_total{job="proxmox-host",device!="lo"}[5m]) / 1024 / 1024'
            );
            if (netHistory.length > 0) {
                drawSparkline('network-chart', netHistory, '#06B6D4');
            }

            const load1 = await fetchPrometheusQuery('node_load1{job="proxmox-host"}');
            if (load1 !== null) {
                document.getElementById('load-value').textContent = load1.toFixed(2);
            }

            const uptime = await fetchPrometheusQuery('node_time_seconds{job="proxmox-host"} - node_boot_time_seconds{job="proxmox-host"}');
            if (uptime !== null) {
                document.getElementById('uptime-value').textContent = formatUptime(uptime);
            }
        }

        async function initDashboard() {
            const dashboard = document.getElementById('dashboard');
            dashboard.innerHTML = '';

            const metrics = [
                { id: 'cpu', label: 'CPU Usage', icon: 'âš¡', unit: '%', showProgress: true },
                { id: 'memory', label: 'Memory Usage', icon: 'ðŸ’¾', unit: '%', showProgress: true },
                { id: 'disk', label: 'Disk Usage', icon: 'ðŸ’¿', unit: '%', showProgress: true },
                { id: 'network', label: 'Network RX', icon: 'ðŸŒ', unit: 'MB/s', showProgress: false },
                { id: 'load', label: 'System Load (1m)', icon: 'ðŸ“Š', unit: '', showProgress: false },
                { id: 'uptime', label: 'Uptime', icon: 'â±ï¸', unit: '', showProgress: false }
            ];

            metrics.forEach(metric => {
                dashboard.appendChild(createMetricCard(metric));
            });

            await updateDashboard();
            setInterval(updateDashboard, REFRESH_INTERVAL);
        }

        initDashboard();
    </script>
</body>
</html>
